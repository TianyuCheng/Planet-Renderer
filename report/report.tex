\documentclass[10pt,twocolumn]{article}

\usepackage{times}
\usepackage{url}

\author{Tianyu Cheng, Xinya Zhang}
\title{Final Project Report: Terrain Renderer}

\begin{document}
\maketitle
\begin{abstract}
	In this project we are trying to combine different techniques to
	actual render a complex scene which is a part of a planet. Our plan
	includes terrain, water, tree and grass rendering, as well as the sky
	and the sun.
\end{abstract}

\section{Problems to address}

These are a lot of different parts to render a field, say the terrain and
grass. However, due to the limitation from time we are not
trying to address any of them in a perfect way. For example, a perfect terrain
requires shadowing, especially self-shadowing, which eventually leads to some
global illumination algorithm. On the contrary, we are focusing on integrate
the different parts together to form our terrain rendering.

In our terrain renderer, we mainly implemented the following items:
\begin{enumerate}
	\item Terrain
	\item Water
	\item Plants
	\item Sky
\end{enumerate}

A brief description about those items will shown in Section 2. The essential
data structure and application architecture is designed in Section 3.

\section{Rendering}

This section will focus on different rendering techniques for items in our
scene.

\subsection{Terrain}

In our renderer, Terrain is generated by a square mesh with height from a
texture, which is generated with libnoise\cite{libnoise}. We refer this texture as heightmap in the following text. This task
is straightforward and is done in the vertex shader. However, we want nearer
terrain shows better details, thus we need to introduce some sort of
level-of-detail (LOD) system.

Inspired by \cite{CDLOD}, we adopted the following LOD system in our Terrain
system. First, we split the whole terrain into multiple patches, and each
patch uses the same mesh to represent the surface. Second, we will further
divide near terrain patches into sub-patches. Since we are using the same mesh
for all patches, the nearer part of terrain will have more details because of
more terrain patches. Terrain patches are generated according to the camera.
We modified frustum culling a little bit to generate those terrain patches. To
achieve seamless boundary between two patches, nearby patches will be
overlapped a little bit.

Terrain may have different textures, currently the texture for some terrain is
selected according to the height, which changes from grass to dirty land and
eventually snow. We also blend the textures the fragment is close to the
boundary of switching textures.

\subsection{Water}

A reasonable water implementation, in our opinion, should include the
reflection and waves. The reflection is done by using another rendering pass
to draw the reflected image from the water with another ``reflection'' camera
which is symmetry to our main camera.

The waves are generated according to the first chapter from
\cite{fernando2001gpu}. With Gerstner Waves we are able to implement
acceptable water waves in reasonable cost.

We also implemented the caustics effects under sea, however it is mainly based
on texture mapping.

\subsection{Plants}

We decided to use Billboard to display the plants on the land. Firstly we will
create a mesh to cover the area where we want to have plants. Then we use the
Geometry shader to actual create the primitives of plants on the fly. At last,
the fragment shader will sample pixels from the plant texture for display.

\subsection{Sky}

Sky dome technique is chosen in our renderer to present the sky. We also
modified the fragment shader of the sky dome a little bit to draw the sun on
the sky dome, as well as changing the color of the sky when sunrise and
sunset.

\section{Data structure and design}

We tried to manage a large area of terrain in our renderer. In the best case,
we should be able to manage terrain whose total area is equal to the earth.
To achieve this goal we implemented a hierarchical data structure for manage
terrain sections of different level of details. We call this ``Tile system'',
and each piece of terrain managed by this system is called a ``Tile''. Tile
may have child tiles to store more detailed terrain information. Since we are
simply generating the terrain with libnoise, we are able to store the random
seeds for the whole terrain information, and even the seeds of the child tiles
as we can also generate the seeds.

The tiles are generated on demand, which saves memory for extremely large
scene. We also provide an extractor function to access a part of the terrain
with specific size and resolution.

We also tried a lot of new things in our application design. Firstly we
enforce the use of OpenGL 3.3 Core profile, which has been supported by almost
all platforms. This choice allows us to use Geometry shader in our project.
This application is also crossing platform, based on Qt 5 and its Qt Quick
framework, which gives us greater flexibility in implementing non-graphical
function, say music playing.

We have successfully run this project on Linux and Mac OS X.

\subsection{Future work}

We also planned a lot of things but we are running out of time. Here are some
ideas and regrets about our project.

First we only use a small part of the ``Tile System'' in managing our terrain,
and we even do not have a way to demonstrate it since the integration has not
been done completely.

Second we wanted to generate the terrain and the biomes over it in a more
reasonable way. However this will take much more time than we expected.

Third, we tried to get a globe-like result with spherical terrain. However,
the polar coordinate system of a sphere is much more complex than the
Cartesian coordinate system. We cancelled this idea soon after starting to
implement the Tile System.

At last, we still want a weather system in our renderer.

\bibliography{mybib}{}
\bibliographystyle{plain}
\end{document}
